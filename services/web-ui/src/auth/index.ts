import passport from 'passport';
import { Strategy as JwtStrategy, ExtractJwt } from 'passport-jwt';
import { logger } from '../utils/logger';

/**
 * Authentication setup
 * Configures Passport.js strategies for authentication
 */
export function setupAuthentication(passportInstance: typeof passport): void {
  // Validate JWT secret configuration
  const jwtSecret = process.env.JWT_SECRET;
  const fallbackSecret = 'dev-secret-change-in-production';
  
  if (!jwtSecret) {
    console.warn('WARNING: JWT_SECRET not set, using fallback secret. This is insecure for production!');
  }

  // JWT Strategy configuration
  const jwtOptions = {
    jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
    secretOrKey: jwtSecret || fallbackSecret, // Use fallback only if not set
    issuer: process.env.JWT_ISSUER || 'ai-compliance-shepherd',
    audience: process.env.JWT_AUDIENCE || 'web-ui'
  };

  passportInstance.use(new JwtStrategy(jwtOptions, async (payload, done) => {
    try {
      logger.debug('JWT authentication attempt', {
        userId: payload.sub,
        tenantId: payload.tenantId,
        exp: payload.exp
      });

      // In production, you would validate the user exists and is active
      // For now, we'll use the payload directly
      const user = {
        id: payload.sub,
        email: payload.email,
        tenantId: payload.tenantId,
        role: payload.role || 'user',
        permissions: payload.permissions || [],
        name: payload.name
      };

      return done(null, user);
    } catch (error) {
      logger.error('JWT authentication error', {
        error: error instanceof Error ? error.message : String(error),
        payload: { ...payload, exp: undefined, iat: undefined }
      });
      
      return done(error, false);
    }
  }));

  // Serialize user for session
  passportInstance.serializeUser((user: any, done) => {
    done(null, user.id);
  });

  // Deserialize user from session
  passportInstance.deserializeUser(async (id: string, done) => {
    try {
      // In production, fetch user from database
      // For now, return a mock user
      const user = {
        id,
        email: 'demo@compliance-shepherd.com',
        tenantId: 'tenant-demo-company',
        role: 'admin',
        permissions: ['scan:read', 'scan:write', 'findings:read', 'findings:write'],
        name: 'Demo User'
      };

      done(null, user);
    } catch (error) {
      logger.error('User deserialization error', {
        userId: id,
        error: error instanceof Error ? error.message : String(error)
      });
      
      done(error, null);
    }
  });

  logger.info('Authentication strategies configured', {
    strategies: ['jwt'],
    jwtIssuer: jwtOptions.issuer,
    jwtAudience: jwtOptions.audience
  });
}

/**
 * Generate JWT token for testing/development
 */
export function generateTestToken(user: {
  id: string;
  email: string;
  tenantId: string;
  role: string;
  permissions: string[];
  name?: string;
}): string {
  // This is for development/testing only
  // In production, tokens should be generated by your auth service
  const jwt = require('jsonwebtoken');
  
  const payload = {
    sub: user.id,
    email: user.email,
    tenantId: user.tenantId,
    role: user.role,
    permissions: user.permissions,
    name: user.name,
    iss: process.env.JWT_ISSUER || 'ai-compliance-shepherd',
    aud: process.env.JWT_AUDIENCE || 'web-ui',
    exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours
  };

  return jwt.sign(payload, process.env.JWT_SECRET || 'dev-secret-change-in-production');
}
